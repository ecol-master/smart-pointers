# Smart Pointers

В этом репозитори собраны мои реализации умных указателей в C++
- [unique](./src/unique/unique.h)
- [shared](./src/shared/shared.h)
- [weak](./src/weak/weak.h)
- [intrusive](./src/intrusive/intrusive.h)

Также для реализации `UniquePtr` был написан класс [CompressedPair](./src/unique/compressed_pair.h) для более умного хранения объекта делитера внутри `UniquePtr`.

Тесты для указателей находятся в папке [tests](./tests).

## Usage
В файле [main.cpp](./main.cpp) приведен пример использования умных указателей для реализации дву-связного списка. Запустить код можно с помощью команды:
```bash
clang++ main.cpp -std=c++20 -o main && ./main
```

## IntrusivePtr
`IntrusivePtr` -- умный указатель, похожий по семантике на `SharedPtr`, без возможности брать `WeakPtr` на указатель.
Реализация данного класса намного проще, чем `SharedPtr`.
Это достигается за счет ограничения на пользовательский тип. Он должен удовлетворять следующему условию:
1. Внутри типа находится счетчик ссылок (поэтому указатель интрузивный: счетчик находится прямо в объекте).
1. Есть метод `IncRef()`, уменьшающий внутренний счетчик ссылок
1. Есть метод `DecRef()`, уменьшающий внутренний счетчик ссылок; при достижении нуля объект автоматически разрушается.
1. Есть метод `RefCount()`, возвращающий текущее значения счетчика.

Важно, что все состояние указателя находится в объекте, на который он указывает. Это позволяет создавать корректный `IntrusivePtr` из сырого указателя, ровно как с `enable_shared_from_this`.

Рядом с `IntrusivePtr` реализован удобный класс-миксин, позволяющий вставить счетчик ссылок в любой объект, просто отнаследовавшись от него:
```cpp
class MyClazzWithIntrusiveCounter : public SimpleRefCounted<MyStringWithIntrusiveCounter> {
    ...
};
```

### Зачем он нужен?
За счет более строгих требований на пользовательский тип, чем у `SharedPtr`, и отсутствия `WeakPtr` `IntrusivePtr` реализуется намного проще и эффективнее.
Удобная абстракция со внешним счетчиком ссылок позволяет легко использовать `IntrusivePtr` для нетривиальных времен жизни (например `ObjectPool` в тестах).
Большую часть использований `std::shared_ptr` в вашем коде на самом деле можно заменить на более легковесный `IntrusivePtr`.
